namespace Main;

algebraic orderable typedecl MPH = Int;

algebraic orderable typedecl Fahrenheit = Int;

algebraic orderable typedecl Percent = Float;

enum WindCategory {
    calm,
    windy,
    high,
    dangerous
}

enum ForecastDetail {
    sun,
    showers,
    thunderstorms,
    snow,
    fog
}

enum WindDirection {
    north,
    south,
    east,
    west
}

entity WindInfo provides APIType {
    field direction: WindDirection;
    field min: MPH;
    field max: MPH;

    invariant 0_MPH <= $min && $min <= $max && $max <= 300_MPH;
}

entity TemperatureInfo provides APIType {
    field low: Fahrenheit;
    field high: Fahrenheit;

    invariant -206_Fahrenheit <= $low && $low <= $high && $high <= 212_Fahrenheit;
}

entity Forecast provides APIType {
    field temp: TemperatureInfo;
    field windSpeed: WindInfo;
    field forecastDetail: ForecastDetail;
    field shortForecast: String;
    field forecastPercentage: Percent;

    invariant /Sun|Snow|Wind|Thunderstorms( and Sun|Snow|Wind|Thunderstorms)?/.accepts($shortForecast);
}

enum ExpertiseLevel {
    novice,
    intermediate,
    expert
}

enum GetError {
    internalError
}

enum RequestError {
    insufficientAvailability,
    closedDueToConditions,
    internalError
}

entrypoint function getRentalInventory(): Nat | GetError {
    return s_reshavoc<Nat | GetError>();
}

entrypoint function getRentalReservations(): Nat | GetError {
    return s_reshavoc<Nat | GetError>();
}

entrypoint function processRentalRequest(forecast: Forecast, expertise: ExpertiseLevel, inventory: Int, reservations: Int, requested: Nat, allowPartials: Bool): Nat | RequestError 
    ensures $return.is<Nat>() ==> $return.toInt() <= inventory - reservations;
    ensures !allowPartials && $return.is<Nat>() ==> $return == requested;
{
    return s_reshavoc<Nat | RequestError>();
}
